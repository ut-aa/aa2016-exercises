\documentclass[a4paper]{article}

\usepackage{../styles/new-style}

\newcommand{\hmwkTitle}{Variantide läbivaatamine} % Assignment title
\newcommand{\hmwkClass}{Algoritmid ja andmestruktuurid} % Course/class

\begin{document}

\textbf{Kodutöö esitamise tähtaeg: 1. oktoober, 23:59}

\section*{Variantide läbivaatamine ja kombinatoorika}

Järgnevad ülesanded tuleks lahendada rekursiivsete funktsioonide abil,
taandades ülesande teatavaks arvuks esialgse ülesandega sarnasteks
alamülesanneteks. Proovige ülesanne jaotada osadeks (alamülesanneteks)
nii, et iga osa jaoks saaks rakendada rekursiivselt sama funktsiooni.

Kombinatsioone, permutatsioone ja muid valikuid teostavaid standardfunktsioone kasutada ei tohi.

\begin{problem}
\textbf{Ülesanne 1}
\begin{enumerate}
\item 
Kirjutada rekursiivne meetod, mis väljastab ekraanile kõik
bitivektorid, mille pikkus on võrdne etteantud arvuga. Modifitseerida seda meetodit nii, et ekraanile väljastamise asemel meetod tagastaks kõikide sobivate bitivektorite hulga. Modifitseeritud meetod peaks implementeerima liidest \textit{BitVectorGenerator}.
\end{enumerate}
\end{problem}

\begin{problem}
\textbf{Ülesanne 2}
\newline
Implementeerida liides \textit{SubSetGenerator}.
\begin{enumerate}
\item
Implementeerida rekursiivne meetod \textit{allSubsets}, mis tagastab määratud hulga kõik alamhulgad.
\item
Implementeerida rekursiivne meetod \textit{allSubsetsOfSizeK}, mis tagastab määratud hulga kõik alamhulgad, kus on täpselt \textit{k} elementi.
\end{enumerate}
\end{problem}

\begin{problem}
\textbf{Ülesanne 3}
\newline
Implementeerida liides \textit{PermutationGenerator}.
\begin{enumerate}
\item
Implementeerida rekursiivne meetod, mis võtab parameetriks listi A ja tagastab listi, mis koosneb kõikidest listi A permutatsioonidest.
\end{enumerate}
\end{problem}

\begin{problem}
\textbf{Ülesanne 4}
\newline
\textbf{Järgmistest ülesannetest valida üks ja lahendada see.}

\begin{enumerate}
\item[a)] {\em Bobimeeskonna koostamine.} Realiseerida liides \textit{BobsledTeam}. $n$-liikmelisest
treeningrühmast ($n=10 \pm 2$) tuleb eelolevaks võistluseks välja valida
neljase bobi meeskond. Treeningrühma iga liikme kohta on antud nimi,
kaal ja naturaalarvuline reiting (mis näitab treenituse taset).
Implementeerida meetod \textit{selectTeam}, mis leiab sellise bobimeeskonna, mille kogukaal ei
ületa etteantud väärtust ja mille reitingute summa on võimalikult suur.

 \item[b)] {\em Sobivaima töörühma väljavalimine.} Implementeerida liides \textit{HarmonicWorkgroup}. Antud on töötajate
nimekiri ja sobivusmaatriks $(s_{ij})$, mille element $s_{ij}$ näitab töötajate
$i$ ja $j$ vastastikuse sobivuse taset reaalarvuna lõigul $[0;1]$.
Implementeerida meetod \textit{selectWorkgroup}, mis leiab võimalikult suure rühma töötajaid, mille
korral vastastikuste sobivuste keskmine on suurem kui 0{,}5.


 \item[c) ] {\em Praktikumijuhendajaga kokkuleppel} valida ise üks
ülesanne, mille lahendusalgoritm vajab kõikide variantide läbivaatamist
(kas siis eks\-po\-nent\-siaal- või faktoriaalkeerukusega algoritmi abil).
Nõutav on, et see ülesanne teeks midagi "`kasulikku"'.
\end{enumerate}
\end{problem}

\section*{Lihtsamad puud}

Puu on hierarhiline andmestruktuur, mis koosneb \textbf{tippudest} (ehk sõlmedest; inglise keeles \emph{nodes} või \emph{vertices}), ja nende vahelistest \textbf{servadest} \emph{(edges)}. Servad ühendavad tippu tema \textbf{vanemaga} \emph{(parent)} ning \textbf{lastega} \emph{(children)}. Igas mittetriviaalses\footnote{Triviaalne puu on niisugune puu, mis ei sisalda ühtegi tippu ega kaart ehk tühi puu.} puus võib eristada üht tippu, mida nimetatakse \textbf{juureks} \emph{(root)}. Igal tipul on täpselt üks vanem v.a juurtipp, millel ei ole vanemat. Tippe, millel ei ole lapsi, nimetatakse \textbf{lehtedeks} (\emph{leafs}). Täpsemalt puudest ja nende tüüpidest räägitakse hilisemates loengutes.

Selles praktikumis me vaatleme üht lihtsamat puutüüpi --- \textbf{kahendpuud}. Kahendpuu tippudel võib olla maksimaalselt kaks last, mille järjekord on tavaliselt tähtis (öeldakse \emph{vasak} ja \emph{parem} laps). Niisuguse puu tipu realisatsioon võib olla järgmine (täielik realisatsioon on toodud lab-2 projektis):

\begin{lstlisting}
public class BinaryTreeVertex<Data>{
	private BinaryTreeVertex<Data> parent = null;
	private BinaryTreeVertex<Data> leftVertex = null;
	private BinaryTreeVertex<Data> rightVertex = null;
	
	private Data data = null;
}
\end{lstlisting}

Järgmised ülesanded eeldavad seda, et etteantud puu on esitatud, kasutades tippude jaoks projektis antud \textit{BinaryTreeVertex} realisatsiooni.

\begin{problem}
\textbf{Ülesanne 5}
\newline
Implementeerida liides \textit{BinaryTreeMeasurer}.
\begin{enumerate}
\item
Implementeerida meetod \textit{measureTreeHeight}, mis tagastab etteantud puu kõrguse.
Arvestada, et ühetipulise puu kõrgus on 0.
\item
Implementeerida meetod \textit{countNodes}, mis tagastab etteantud puu tippude arvu.
\item
Implementeerida meetod \textit{countLeaves}, mis tagastab etteantud puu lehtede arvu.
\end{enumerate}
\end{problem}

\begin{problem}
\textbf{Ülesanne 6}
\newline
Implementeerida liides \textit{BinaryTreeDataCounter}. Selleks implementeerida meetod \textit{countData}, mis tagastab mitu tippu sisaldab meetodi argumendina saadud väärtust.
\end{problem}

\url{https://github.com/ut-aa/aa2016-lab2}

\end{document}